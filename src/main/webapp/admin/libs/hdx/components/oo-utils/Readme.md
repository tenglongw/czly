OO Utils
==========

Provides utility functions for object-oriented JavaScript.


## Getting Started
---------------

* Register oo-utils and JQuery as a dependencies in bower.json
* Expose oo-utils via requireJs


## Functions

### create()

Uses JavaScript's Object.create() to instance an object and optionally extends / overrides some fields.

```
    var myObj = {

        /**
         * A field
         * @type int
         */
        PROP_MULTIPLICATION_FACTOR : 2,

        /**
         * Multiplies the given value by a factor and returns the result.
         *
         * @param {int} val
         * @return {String}
         */
        calculateAndReport : function (val) {
            //call another method on this object to calculate the result.
            var result = this.calculate(val);

            return "The result is " + result;
        },

        /**
         * Multiplies the given value by a factor
         *
         * @param {int} val
         * @return {int}
         */
        calculate : function (val) {
            //multiply by the factor
            return val * this.PROP_MULTIPLICATION_FACTOR;
        }
    };

    var myInstance = ooUtils.create(myObj);

    myInstance.calculateAndReport(7); // returns "The result is 14"



    var myOverride = ooUtils.create(myObj, /** @lends myOverride# */{

        //Note the @lends in the line above: this is a hint for jsDoc to tell it that the members here are being "lent"
        //to the prototype of OverrideExampleJsBoundModule.  The "#" at the end tells it that they are instance members,
        //not static members.  Long story short, you need @lends when using Object.create() for the API docs generated by
        //jsDocToolkit to be correct.

        /**
         * Overrides superclass method to add 2 to the result.
         *
         * @param {int} val
         * @return {int}
         */
        calculate : function (val) {
            var defaultValue = myOverride.protoChain.calculate.call(this, val);//call a "super" function.

            //add 2
            return defaultValue + 2;
        }
    });

    var myOtherInstance = ooUtils.create(myOverride);

    myOtherInstance.calculateAndReport(7); // returns "The result is 16"

```


### makePlugin()

Creates a jQuery plugin from an object in a predictable way

```

var _defaultOptions = {
    someOption: true
};

var myPluginObj = {
    init: function (options, elem) {
        // Mix in the passed-in options with the default options
        var resolvedOptions = this.resolvedOptions = $.extend({}, _defaultOptions, options);
        var $elem = $(elem);

        // Init a wrapped plugin, if needed
        $elem.someOffTheShelfPlugin();

        //Expose the wrapped plugin for convenience of calling functions on it directly from this plugin.
        this.wrappedPluginDataKeys = ["someOffTheShelfPlugin"];

        // return this so that we can chain and use the bridge with less code.
        return this;
    }
};


ooUtils.makePlugin('myPluginName', myPluginObject);

```

After you register a plugin, you can...

* Instance the new plugin on '#myElem': $('#elem').myPluginName();
* Pass options when creating an instance: $('#elem').myPluginName({name: "John"})
* Operate on an instance:
** $('#elem').data('myPluginName').myFunction();
** $('#elem').myPluginName().myFunction();
** $('#elem').myPluginName('myFunction');
* Call any function exposed by a wrapped plugin, provided your plugin provides a 'wrappedPluginDataKeys' member:
** $('#elem').myPluginName('myFunctionThatExistsOnAWrappedPlugin');


### getPlugin()

Allows a developer to get any plugin object previously registered with makePlugin(), useful for extending that plugin.

```

ooUtils.makePlugin('aPlugin', obj1);

```

and then, sometime later, in a different js file...

```

var originalPlugin = ooUtils.getPlugin("aPlugin"); //get the original obj1, which was defined elsewhere
var myOtherPlugin = ooUtils.create(originalPlugin, anotherObj); // extend
ooUtils.makePlugin("anotherPlugin", myOtherPlugin); // register the extended object

```

